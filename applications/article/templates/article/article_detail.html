{% extends "base.html" %}
{% load article_extras %}
{% load static %}


{% block title %}{{ article.title|truncatechars:60 }}{% endblock %}

{% block extra_head %}
<style>

    .article-page{
        display: flex;
        gap: 20px;
        flex: 1;
    }

    .article-page h2{
        margin-top: 0px;
    }

    .article-page-column{
        display: flex;
        flex-direction: column;
        max-height: 100%;
        position: relative;
        overflow: hidden;
    }

    .article-other-info .tab-container{
        position: absolute;
    }

     .article-page-column:first-child{
        flex: 0.35;
     }

     .article-page-column:last-child{
        flex: 0.65;
     }

    .detail-section {
        padding-bottom: 15px;
        /* border-bottom: 1px solid #eee; */
    }
    .detail-section h3 {
        margin-top: 0;
        color: #555;
    }
    .metadata-grid {
        display: grid;
        grid-template-columns: 150px 1fr;
        gap: 5px 15px;
    }
    .metadata-grid dt {
        font-weight: bold;
        color: #333;
    }
    .metadata-grid dd {
        margin-left: 0;
    }

    .content-list,.reference-list{
        margin: 0;
    }

    .content-list li, .reference-list li {
        background-color:var(--light-button-bg-color);
        border: 1px solid var(--border-color);
        padding: 10px;
        margin-bottom: 8px;
        border-radius: 3px;
        border-left: 3px solid var(--primary-color);
    }
    .reference-list li .status {
        font-size: 0.85em;
        color: #666;
        display: block;
        margin-top: 5px;
    }

    .raw-content-toggle {
        cursor: pointer;
        color: var(--primary-color);
        text-decoration: underline;
        font-size: 0.9em;
    }
    .raw-content-data {
        display: none;
        white-space: pre-wrap;
        background-color: #272822;
        color: #f8f8f2;
        padding: 10px;
        border-radius: 4px;
        margin-top: 5px;
        max-height: 300px;
        overflow-y: auto;
        font-family: monospace;
    }

    /* ... styles for editing parts of an article ... */
    .section-editor {
        display: flex;
        flex-direction: column;
        justify-content: center;
        margin-bottom: 15px;
        border-radius: var(--border-radius);
        padding: 10px;
        border: 1px solid var(--border-color);
        background-color: var(--light-button-bg-color);
    }

    #display-title:empty{
        display: none;
    }

    .section-editor h4 button{
        margin-left: 10px;
    }

    .section-editor h4{
        margin-bottom: 10px;
        margin-top: 20px;
    }

    .section-editor:last-child{
    margin-bottom: 0px;
    }

    .section-editor textarea {
        width: calc(100% - 22px);
        min-height: 150px;
        padding: 10px;
        margin-bottom: 10px;
        border: 1px solid #ccc;
    }
    .section-display {
        padding: 5px 0;
    }
    .edit-section-btn {
        font-size: 0.8em;
        padding: 4px 8px;
        cursor: pointer;
    }

    .section-editor{

    }

    /* .save-section-btn {
        background-color: #5cb85c;
        color: white;
    } */
    /* .cancel-section-btn {
        background-color: #aaa;
        color: white;
    } */

    .add-section-btn {
        /* display: block;
        padding: 10px 15px;
        background-color: var(--primary-color);  */
        /* Info color */
        /* color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        text-align: center; */
    }

    .actions{
        display: flex;
        gap: 10px;

        flex-wrap: wrap;
    }

    .reference-list .actions{
        margin-top: 10px;
    }

    .reference-list .actions button, .section-editor .actions button{
        font-size: 0.8em;
        padding: 3px 6px;
    }

    .section-editor h5{
        margin: 0;
        font-size: inherit;
    }

    /* .add-section-btn:hover { background-color: var(--primary-color); } */

    /* styles for analyzed sections of text */

    .segment-section-group {
        padding-top: 10px;
    }

    .segment-section-group:last-child{
        margin-bottom: 0px;
    }

    .segment-section-group-head{
        display: flex;
        background-color: var(--bg-color-pair-n);
        color: inherit;
        padding: 8px 12px;
        gap: 10px;
        border-radius: 4px;
        width: 100%;
        text-align: center;
        border: 0;
        /* padding-left: calc(12px + 10px + 16px); */
    }

    .segment-section-group-head h4 {
        flex: 1;
        margin: 0;
        /* border-bottom: 2px solid #e0e2e5; */
    }

    .segment-section-group-head svg{
        height: 18.666px;
        display: flex;
        rotate: 180deg;
    }

    .analyzed-segment-item {
        border: 1px solid #d1e7fd;
        background-color: #f8f9fa;
        padding: 15px;
        margin-bottom: 15px;
        border-radius: 4px;
        /* position: relative; For positioning buttons */
    }

    .analyzed-segment-item .actions button{
        font-size: 0.8em;
        padding: 3px 6px;
    }

    .analyzed-segment-item p {
        margin-top: 0;
        line-height: 1.6;
    }
    .segment-references-list {
        list-style-type: none;
        padding-left: 15px;
        margin-top: 10px;
        font-size: 0.9em;
        border-top: 1px dashed #ccc;
        padding-top: 10px;
    }
    .segment-references-list li {
        margin-bottom: 5px;
    }

    .analyzed-segment-list{
        margin-top: 10px;
        display: none;
    }

    .show .analyzed-segment-list{
        display: block;
    }

    .show .segment-section-group-head svg{
        rotate: 0deg;
    }

</style>
{% endblock %}

{% block content %}
{# *** Notification block *** #}
<div id="notifications-wrapper">
    <div id="notifications">
        {# Messages will be added here by JavaScript. #}
        <p style="text-align: center; color: #6c757d; margin: 5px 0;">Waiting for notifications...</p>
    </div>

    <botton id="notifications-toggle-button">
        <svg class="toggle-button-closed-svg" width="24" height="24" viewBox="0 0 26 26" fill="none" xmlns="http://www.w3.org/2000/svg">
            <g filter="url(#filter0_d_8537_320451)">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M6.00066 9C6.00066 7.14348 6.73816 5.36301 8.05092 4.05025C9.36367 2.7375 11.1441 2 13.0007 2C14.8572 2 16.6377 2.7375 17.9504 4.05025C19.2632 5.36301 20.0007 7.14348 20.0007 9V12.764L21.8227 16.408C21.9065 16.5757 21.9461 16.7621 21.9377 16.9494C21.9293 17.1368 21.8731 17.3188 21.7745 17.4783C21.6759 17.6379 21.5382 17.7695 21.3744 17.8608C21.2106 17.9521 21.0262 18 20.8387 18H16.8747C16.6522 18.8582 16.1511 19.6183 15.4499 20.1609C14.7488 20.7035 13.8873 20.9979 13.0007 20.9979C12.1141 20.9979 11.2526 20.7035 10.5514 20.1609C9.85023 19.6183 9.3491 18.8582 9.12666 18H5.16266C4.97514 18 4.79072 17.9521 4.62693 17.8608C4.46314 17.7695 4.3254 17.6379 4.22681 17.4783C4.12822 17.3188 4.07204 17.1368 4.06361 16.9494C4.05518 16.7621 4.09479 16.5757 4.17866 16.408L6.00066 12.764V9ZM11.2687 18C11.4442 18.304 11.6967 18.5565 12.0007 18.732C12.3047 18.9075 12.6496 18.9999 13.0007 18.9999C13.3517 18.9999 13.6966 18.9075 14.0006 18.732C14.3046 18.5565 14.5571 18.304 14.7327 18H11.2687ZM13.0007 4C11.6746 4 10.4028 4.52678 9.46513 5.46447C8.52745 6.40215 8.00066 7.67392 8.00066 9V12.764C8.00064 13.0743 7.9284 13.3804 7.78966 13.658L6.61966 16H19.3827L18.2127 13.658C18.0736 13.3805 18.001 13.0744 18.0007 12.764V9C18.0007 7.67392 17.4739 6.40215 16.5362 5.46447C15.5985 4.52678 14.3267 4 13.0007 4Z" fill="black"/>
            </g>
        </svg>

        <svg class="toggle-button-opened-svg" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M6.4 19L5 17.6L10.6 12L5 6.4L6.4 5L12 10.6L17.6 5L19 6.4L13.4 12L19 17.6L17.6 19L12 13.4L6.4 19Z" fill="black"/>
        </svg>
    </botton>
</div>

<div class="container">
    <div class="article-page">
        <div class="article-current-info article-page-column" style="position: relative;">
            <div class="scrollable-content" style="position: absolute; left: 0;top: 0; border:none; padding: 0;">
                <form style="display:none;">
                    {# *** Dummy form with CSRF token *** #}
                    {% csrf_token %}
                </form>

                {{ references_for_js|json_script:"article-references-data-script" }}

                <h2>{{ article.title|default:"(Title not defined)" }}</h2>

                <div class="detail-section metadata">
                    <h3>Basic information</h3>

                    <dl class="metadata-grid">
                        <dt>Authors:</dt>
                        <dd>
                            {% for author in article.authors.all %}
                                {{ author.full_name }}{% if not forloop.last %}; {% endif %}
                            {% empty %}
                                Do not exist
                            {% endfor %}
                        </dd>
                        <dt>DOI:</dt><dd>{{ article.doi|default:"-" }}</dd>
                        <dt>PMID:</dt><dd>{{ article.pubmed_id|default:"-" }}</dd>
                        <dt>arXiv ID:</dt><dd>{{ article.arxiv_id|default:"-" }}</dd>
                        <dt>Date of publication:</dt><dd>{{ article.publication_date|date:"d.m.Y"|default:"-" }}</dd>
                        <dt>Journal/Source:</dt><dd>{{ article.journal_name|default:"-" }}</dd>
                        <dt>Source of main data:</dt><dd>{{ article.primary_source_api|upper|default:"-" }}</dd>
                        <dt>PDF OA URL:</dt><dd><a href="{{ article.best_oa_pdf_url }}" target="_blank" rel="noopener noreferrer">{{ article.best_oa_pdf_url }}</a></dd>
                        <dt>PDF file:</dt><dd>{% if article.pdf_file %}<a href="{{ article.pdf_file.url }}" target="_blank">PDF file of the article</a>{% endif %}</dd>
                    </dl>
                </div>

                <div class="actions" style="margin-bottom:20px;">
                    <button onclick="deleteArticle('{{ article.id }}', this)" class="cancel-button">Delete article</button>
                </div>
            </div>
        </div>

        <div class="article-other-info article-page-column">
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button" data-tab="available-content-and-raw-data">Available content and raw data</button>
                    <button class="tab-button" data-tab="automatically-linked-text-segments">Automatically linked text segments</button>
                    <button class="tab-button" data-tab="content-of-the-article-by-section">Article content by sections (editable)</button>
                    <button class="tab-button" data-tab="other-sections">Other sections</button>
                    <button class="tab-button" data-tab="structured-content-of-the-article">Structured content of the article</button>
                    <button class="tab-button" data-tab="clear-text-for-llm">Cleaned Text (for LLM)</button>
                    <button class="tab-button" data-tab="list-of-references">References ({{ references_made|length }})</button>
                </div>

                <div class="tab-content" id="available-content-and-raw-data">
                    {% if contents %}
                            <h3>Available content and raw data</h3>
                            <div class="scrollable-content">
                                <ul class="content-list" style="padding-left:0; list-style:none;">
                                    {% for content_item in contents %}
                                    <li>
                                        <strong>{{ content_item.source_api_name|upper }}</strong> - {{ content_item.format_type }}
                                        <small>(Uploaded: {{ content_item.retrieved_at|date:"d.m.Y H:i" }})</small>

                                        {% if content_item.format_type == "link_openaccess_pdf" %}
                                            <br><a href="{{ content_item.content }}" target="_blank" rel="noopener noreferrer">Link to PDF</a>
                                        {% else %}
                                            <br><span class="raw-content-toggle" onclick="toggleRawContent(this, 'content-{{ content_item.id }}')">Show/hide data</span>
                                            <div id="content-{{ content_item.id }}" class="raw-content-data">{% autoescape off %}{{ content_item.content }}{% endautoescape %}</div>
                                        {% endif %}
                                    </li>
                                    {% endfor %}

                                    {% if article.pdf_text %}
                                        <li>
                                            <strong>PDF</strong> - text
                                            <small>(Uploaded: {{ article.created_at|date:"d.m.Y H:i" }})</small>
                                            <br><span class="raw-content-toggle" onclick="toggleRawContent(this, 'pdf-file-text-{{ article.id }}')">Show/hide data</span>
                                            <div id="pdf-file-text-{{ article.id }}" class="raw-content-data">{% autoescape off %}{{ article.pdf_text }}{% endautoescape %}</div>
                                        </li>
                                    {% endif %}
                                </ul>
                            </div>
                    {% endif %}
                </div>

                <div class="tab-content" id="automatically-linked-text-segments">
                    <h3>Automatically linked text segments</h3>

                    <div class="scrollable-content">
                        {# === BLOCK FOR DISPLAYING SEGMENTS === #}
                        <div class="">
                            <h4 style="margin: 0;">Navigate through sections:</h4>

                            <nav style="margin: 10px 0 10px; display: flex; flex-direction: row; gap:5px; flex-wrap: wrap;">
                                    {% if analyzed_segments %}
                                        {# Group segments by section name #}
                                        {% regroup analyzed_segments by section_key as segments_by_section %}

                                        {% for section in segments_by_section %}
                                            <a class="stroked-button" style="flex:auto;text-align: center; color:var(--primary-color); font-size: 13px; padding: 3px 5px;" href='#{{ section.grouper|default:"(Без секции)" }}'>{{ section.grouper|default:"(Без секции)" }}</a>
                                        {% endfor %}
                                    {% endif %}
                            </nav>

                            <div style="border-top: 1px solid;border-color: var(--border-color); margin: 10px 0 0"></div>
                        </div>

                        <div class="detail-section analyzed-segments-wrapper">
                            {% if analyzed_segments %}
                                {# Group segments by section name #}
                                {% regroup analyzed_segments by section_key as segments_by_section %}

                                {% for section in segments_by_section %}
                                    <div class="segment-section-group show" id='{{ section.grouper|default:"(Without section)" }}'>
                                        <button class="segment-section-group-head" onclick="handleSegmentToggle({tab: `{{section.grouper}}`, parentClass: '.segment-section-group', listClass:'.analyzed-segment-list', root:'.analyzed-segments-wrapper'})">
                                            <h4>Section: {{ section.grouper|default:"(Without section)" }}</h4>
                                            <!-- <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                                <path d="M2.93154 10.8426L7.61654 6.23165C7.71876 6.13052 7.85675 6.07379 8.00054 6.07379C8.14433 6.07379 8.28232 6.13052 8.38454 6.23165L13.0695 10.8416C13.1724 10.9427 13.3108 10.9994 13.455 10.9994C13.5992 10.9994 13.7377 10.9427 13.8405 10.8416C13.8912 10.7923 13.9314 10.7333 13.9589 10.6681C13.9864 10.6029 14.0006 10.5329 14.0006 10.4621C14.0006 10.3914 13.9864 10.3214 13.9589 10.2562C13.9314 10.191 13.8912 10.132 13.8405 10.0826L9.15654 5.47265C8.84802 5.16972 8.43292 5 8.00054 5C7.56816 5 7.15306 5.16972 6.84454 5.47265L2.16054 10.0826C2.10974 10.132 2.06936 10.1911 2.04178 10.2564C2.01421 10.3217 2 10.3918 2 10.4626C2 10.5335 2.01421 10.6036 2.04178 10.6689C2.06936 10.7342 2.10974 10.7933 2.16054 10.8426C2.2634 10.9437 2.40183 11.0004 2.54604 11.0004C2.69025 11.0004 2.82869 10.9437 2.93154 10.8426Z" fill="black"/>
                                            </svg> -->
                                        </button>

                                        <div class="analyzed-segment-list">
                                        {% for segment in section.list %}
                                            <div class="analyzed-segment-item" id="segment-{{ segment.pk }}">
                                                {# Segment (paragraph) text #}
                                                <p>{{ segment.segment_text|linebreaksbr }}</p>

                                                {# Displaying related links #}
                                                {% if segment.cited_references.all %}
                                                    <strong>Related sources:</strong>

                                                    <ul class="segment-references-list">

                                                    {% for ref_link in segment.cited_references.all|dictsort:"manual_data_json.jats_ref_id" %}
                                                        <li>
                                                            <span style="font-weight: bold; color: #0056b3;">
                                                                {% if ref_link.manual_data_json.jats_ref_id %}
                                                                    [{{ ref_link.manual_data_json.jats_ref_id }}]
                                                                {% endif %}
                                                            </span>

                                                            {% if ref_link.resolved_article %}
                                                                <a href="{% url 'article_detail' ref_link.resolved_article.pk %}"
                                                                    title="{{ ref_link.resolved_article.title }}"
                                                                    style={% for au in ref_link.resolved_article.articleuser_set.all %}
                                                                                {% if au.user == user and au.cleaned_text_for_llm or ref_link.resolved_article.pdf_text %}"color: #0056b3;"{% else %}"color: #d9534f;"{% endif %}
                                                                            {% endfor %}>
                                                                    {{ ref_link.resolved_article.title|truncatechars:80 }}
                                                                </a>
                                                            {% elif ref_link.manual_data_json.title %}
                                                                {{ ref_link.manual_data_json.title|truncatechars:80 }}
                                                            {% else %}
                                                                {{ ref_link.raw_reference_text|truncatechars:80 }}
                                                            {% endif %}

                                                            {% if ref_link.target_article_doi %}
                                                                <small> (DOI: {{ ref_link.target_article_doi }})</small>
                                                            {% endif %}
                                                        </li>
                                                    {% endfor %}
                                                    </ul>
                                                {% else %}
                                                    <p><small><i>No related links found in this segment.</i></small></p>
                                                {% endif %}

                                                <div id="llm-analysis-results-{{ segment.pk }}" style="margin-top: 10px; padding: 8px; background-color: #f0f8ff; border-radius: 3px;">
                                                    <strong>LLM Analysis:</strong>

                                                    {% if segment.llm_analysis_notes %}
                                                        <p><i>Notes:</i> {{ segment.llm_analysis_notes|linebreaksbr }}</p>
                                                        <p><i>Reliability assessment (1-5):</i> {{ segment.llm_veracity_score|default:"not rated" }}</p>
                                                        <p><small>Model: {{ segment.llm_model_name|default:"not defined" }} ({{ segment.updated_at|date:"d.m.Y H:i" }})</small></p>
                                                    {% else %}
                                                        <p>The analysis has not yet been conducted or is in progress.</p>
                                                    {% endif %}
                                                </div>

                                                <div class="actions" style="margin-top: 10px;">
                                                    <button class="llm-analyze-segment-btn" data-segment-id="{{ segment.pk }}">Analyze with LLM</button>
                                                    <button disabled title="Not implemented yet">Edit</button>
                                                    <button disabled title="Not implemented yet" style="background-color:#d9534f; color:white;">Delete</button>
                                                </div>
                                            </div>
                                        {% endfor %}
                                        </div>
                                    </div>
                                {% endfor %}
                            {% else %}
                                <p>There are no parsable segments created for this article yet. If you uploaded the full text in XML format, the task to create them may still be in the queue.</p>
                            {% endif %}
                        </div>
                    </div>
                    {# === CREATE SEGMENT BUTTON (appears when text is selected) === #}
                    <button type="button" class="primary-button" id="createSegmentBtn">Create segment from selection</button>
                </div>

                <div class="tab-content" id="content-of-the-article-by-section">
                    <h3>Article content by sections (editable)</h3>

                    <div class="scrollable-content">
                        {% with standard_sections="title,abstract,introduction,methods,results,discussion,conclusion"|split:"," %}
                            {% for section_key in standard_sections %}
                                <div class="section-editor" id="section-{{ section_key }}">
                                    <h4>
                                        {{ section_key|capfirst }}
                                        <button type="button" class="edit-section-btn" data-section="{{ section_key }}">Edit</button>
                                    </h4>

                                    <div class="section-display" id="display-{{ section_key }}">
                                        {{ article_user.structured_content|json_script:"initial-structured-content-data" }}
                                    </div>

                                    <div class="section-form" id="form-{{ section_key }}" style="display:none;">
                                        <textarea id="textarea-{{ section_key }}">
                                            {{ article_user.structured_content|get_item:section_key|default:"" }}
                                        </textarea>

                                        <div class="actions">
                                            <button type="button" class="save-section-btn" data-section="{{ section_key }}">Save</button>
                                            <button type="button" class="cancel-button cancel-section-btn" data-section="{{ section_key }}">Cancel</button>
                                        </div>
                                    </div>
                                </div>
                            {% endfor %}
                        {% endwith %}

                        {% if article_user.structured_content.full_body_fallback and not article_user.structured_content.introduction %}
                            {# Show fallback if there are no main sections #}
                            <h4>Main text (without obvious sections):</h4>

                            <div class="section-editor">
                                <p>{{ article_user.structured_content.full_body_fallback|linebreaksbr }}</p>
                            </div>
                        {% endif %}
                    </div>
                </div>

                <div class="tab-content" id="other-sections">
                    {% if article_user.structured_content.other_sections %}
                        <h3>Other sections:</h3>

                        <div class="scrollable-content">
                            {% for other_sec in article_user.structured_content.other_sections %}
                                {# Add an ID to the section wrapper for easy removal from the DOM #}
                                <div class="section-editor" id="custom-section-{{ forloop.counter0 }}">
                                    <h5>{{ other_sec.title|default:"Without title" }}</h5>

                                    <div class="section-display">
                                        {{ other_sec.text|default:"(Текст отсутствует)"|linebreaksbr }}
                                    </div>

                                    <div class="actions">
                                        <button type="button" class="delete-custom-section-btn cancel-button"
                                            data-section-index="{{ forloop.counter0 }}"
                                            data-section-title="{{ other_sec.title|default_if_none:''|escapejs }}">
                                                Delete this section
                                        </button>
                                    </div>
                                </div>
                            {% endfor %}
                        </div>
                    {% endif %}

                    <button type="button"  id="openAddSectionModalBtn">Add section</button>
                </div>

                <div class="tab-content" id="structured-content-of-the-article">
                    {% if article_user.structured_content %}
                        <h3>Structured content of the article</h3>

                        <div class="scrollable-content" style="padding: 20px 20px 0;">

                            {% if article_user.structured_content.title %}
                                <h4>{{ article_user.structured_content.title }}</h4>
                            {% endif %}

                            {% if article_user.structured_content.abstract %}
                                <div class="content-section">
                                    <h5>Abstract</h5>
                                    <p>{{ article_user.structured_content.abstract|linebreaksbr }}</p>
                                </div>
                            {% endif %}

                            {% if article_user.structured_content.introduction %}
                                <div class="content-section">
                                    <h5>Introduction</h5>
                                    <p>{{ article_user.structured_content.introduction|linebreaksbr }}</p>
                                </div>
                            {% endif %}

                            {% if article_user.structured_content.methods %}
                                <div class="content-section">
                                    <h5>Methods (Методы)</h5>
                                    <p>{{ article_user.structured_content.methods|linebreaksbr }}</p>
                                </div>
                            {% endif %}

                            {% if article_user.structured_content.results %}
                                <div class="content-section">
                                    <h5>Results</h5>
                                    <p>{{ article_user.structured_content.results|linebreaksbr }}</p>
                                </div>
                            {% endif %}

                            {% if article_user.structured_content.discussion %}
                                <div class="content-section">
                                    <h5>Discussion</h5>
                                    <p>{{ article_user.structured_content.discussion|linebreaksbr }}</p>
                                </div>
                            {% endif %}

                            {% if article_user.structured_content.other_sections %}
                                {% for sec in article_user.structured_content.other_sections %}
                                    <div class="content-section">
                                        <h5>{{ sec.title|default:"Additional section" }}</h5>
                                        <p>{{ sec.text|linebreaksbr }}</p>
                                    </div>
                                {% endfor %}
                            {% endif %}

                            {% if article_user.structured_content.conclusion %}
                                <div class="content-section">
                                    <h5>Conclusion</h5>
                                    <p>{{ article_user.structured_content.conclusion|linebreaksbr }}</p>
                                </div>
                            {% endif %}

                            {% if not article_user.structured_content.introduction and not article_user.structured_content.methods and article_user.structured_content.full_body_fallback %}
                                <div class="content-section">
                                    <h5>Main text (without sections)</h5>
                                    <p>{{ article_user.structured_content.full_body_fallback|linebreaksbr }}</p>
                                </div>
                            {% endif %}
                        </div>
                    {% endif %}
                </div>

                <div class="tab-content" id="clear-text-for-llm">
                    {% if article_user.cleaned_text_for_llm %}
                            <h3>Cleaned Text (for LLM)</h3>
                            <div class="scrollable-content">
                                {{ article_user.cleaned_text_for_llm|linebreaksbr }}
                            </div>
                    {% endif %}
                </div>

                <div class="tab-content" id="list-of-references">
                    {% if references_made %}
                        <h3>References ({{ references_made|length }})</h3>

                        <div class="actions">
                            <button onclick="findAllReferenceDois('{{ article.id }}', this)">Find DOI for all unfound</button>
                            <button onclick="loadAllLinkedReferences('{{ article.id }}', this)">Download all from DOI</button>
                            <button type="button" class="add-section-btn stroked-button" onclick="openAddReferenceModal()">Add link manually</button>
                        </div>

                        <div class="scrollable-content">
                            <ul class="reference-list" style="padding-left:0; list-style:none;">
                                {% for ref in references_made %}
                                    <li>
                                        <p>
                                            {% if ref.manual_data_json.title %}
                                                Reference #{{ forloop.counter }}: <strong>{{ ref.manual_data_json.title }}</strong><br>
                                            {% endif %}

                                            {% if ref.raw_reference_text %}
                                                {{ ref.raw_reference_text|truncatechars:200 }}<br>
                                            {% endif %}

                                            {% if ref.manual_data_json.year %}
                                                (Year: {{ ref.manual_data_json.year }})
                                            {% endif %}
                                        </p>

                                        <p>
                                            <strong>Target DOI: </strong>{{ ref.target_article_doi|default:"Not found" }} <br>
                                            <strong>PubMed ID: </strong>{{ ref.resolved_article.pubmed_id|default:"Not found" }} <br>
                                            <strong>PubMed Central ID (PMC): </strong>{{ ref.resolved_article.pmc_id|default:"Not found" }}

                                            <br>

                                            {% if ref.resolved_article.pdf_file %}
                                                <strong>PDF: </strong>
                                                <a href="{{ ref.resolved_article.pdf_file.url }}" target="_blank">Open PDF file of the article</a>
                                            {% else %}
                                                <strong>PDF: </strong>No PDF file of the article
                                            {% endif %}

                                            <br>

                                            {% if ref.resolved_article %}
                                                <strong>Status in DB: </strong>Related to the article <a href="{% url 'article_detail' ref.resolved_article.pk %}">"{{ ref.resolved_article.title|truncatechars:50 }}"</a>
                                            {% else %}
                                                <strong>Status in DB: </strong>Not related to local article
                                            {% endif %}
                                        </p>

                                        <span class="status">Reference processing status: {{ ref.get_status_display }}</span>

                                        <div class="actions">
                                            {% if not ref.target_article_doi and ref.status != "doi_lookup_in_progress" %}
                                                {# Don't show button if already in search #}
                                                <button onclick="findDoiForReference({{ ref.id }}, this)">Find DOI</button>
                                            {% elif ref.status == "doi_lookup_in_progress" %}
                                                <button disabled>Search DOI...</button>
                                            {% else %}
                                                <button disabled title="DOI already found or exists">Find DOI</button>
                                            {% endif %}

                                            {% if ref.target_article_doi and not ref.resolved_article and ref.status != "article_fetch_in_progress" %}
                                                <button onclick="loadReferencedArticle({{ ref.id }}, this)">Download by DOI</button>
                                            {% elif ref.status == "article_fetch_in_progress" %}
                                                <button disabled>Загрузка статьи...</button>
                                            {% else %}
                                                <button disabled title="No DOI or article already uploaded/linked">Download by DOI</button>
                                            {% endif %}

                                            <button onclick="openEditModal({{ ref.id }}, '{{ ref.raw_reference_text|escapejs }}', '{{ ref.target_article_doi|default_if_none:""|escapejs }}', '{{ ref.manual_data_json.title|default_if_none:""|escapejs }}', '{{ ref.manual_data_json.year|default_if_none:""|escapejs }}', '{{ ref.status|escapejs }}', '{{ ref.get_status_display|escapejs }}')">Edit</button>

                                            <button onclick="deleteReference({{ ref.id }}, this)" style="background-color: #d9534f; color:white;">Delete</button>
                                        </div>
                                    </li>
                                {% endfor %}
                            </ul>
                        </div>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>
</div>

{# *** MODAL WINDOW FOR ADDING A LINK *** #}
<div id="addReferenceModal" style="display:none; position:fixed; flex-direction: column; z-index:1050; left:0; top:0; width:100%; height:100%; overflow:auto; background-color:rgba(0,0,0,0.4);">
    <div style="background-color:#fefefe; margin:auto; padding:20px; border:1px solid #888; width:60%; max-width:600px; border-radius:5px;">
        <div style="display: flex; gap: 10px; align-items: center;margin-bottom: 20px;">
            <h3 style="flex:1; margin: 0px;">Add new reference</h3>

            <button onclick="closeAddReferenceModal()" type="button" class="modal-toggle-button" isnotchangabletext="">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M6.4 19L5 17.6L10.6 12L5 6.4L6.4 5L12 10.6L17.6 5L19 6.4L13.4 12L19 17.6L17.6 19L12 13.4L6.4 19Z" fill="black"></path>
                </svg>
            </button>
        </div>

        <form id="addReferenceForm">
            <p>
                <label for="addRefTargetDoi">Target DOI (if known):</label>
                <input type="text" id="addRefTargetDoi" name="target_article_doi" placeholder="10.xxxx/xxxxx">
            </p>

            <p>
                <label for="addRefTitle">Title of the article being cited:</label>
                <input type="text" id="addRefTitle" name="title" placeholder="Название цитируемой статьи">
            </p>

            <p>
                <label for="addRefYear">Year:</label>
                <input type="text" id="addRefYear" name="year" placeholder="ГГГГ">
            </p>

            <p>
                <label for="addRefRawText">Full text of the reference (cited):</label>
                <textarea id="addRefRawText" name="raw_reference_text" rows="3" style="width: calc(100% - 22px); padding:10px; border:1px solid #ddd;"></textarea>
            </p>

            <button type="submit">Save new reference</button>
            <button type="button" onclick="closeAddReferenceModal()" style="background-color:#ccc;">Cancel</button>
        </form>
    </div>
</div>

{# === MODAL WINDOW FOR CREATING A NEW ANALYZED SEGMENT === #}
<div id="segmentCreationModal" style="display:none; flex-direction: column; position:fixed; z-index:1060; left:0; top:0; width:100%; height:100%; overflow:auto; background-color:rgba(0,0,0,0.5);">
    <div style="background-color:#fefefe; margin:auto; padding:20px; border:1px solid #888; width:70%; max-width:700px; border-radius:5px;">
        <span onclick="closeSegmentCreationModal()" style="color:#aaa; float:right; font-size:28px; font-weight:bold; cursor:pointer;">&times;</span>
        <h3>Create a new segment to analyze</h3>

        <form id="segmentCreationForm">
            <p>
                <label for="segmentSectionKey">Section Key/Title (e.g. introduction, methods, or heading):</label>
                <input type="text" id="segmentSectionKey" name="section_key" placeholder="Название секции">
            </p>

            <p>
                <label for="segmentText">Segment text:</label>
                <textarea id="segmentText" name="segment_text" rows="5" style="width: calc(100% - 22px); padding:10px; border:1px solid #ddd;" required></textarea>
            </p>

            <p>
                <label for="segmentInlineCitations">Inline citation markers (separated by commas, eg: [1], (Smith 2023)):</label>
                <input type="text" id="segmentInlineCitations" name="inline_citation_markers" placeholder="[1], [2-5], (Author et al., Year)">
            </p>

            <div style="margin-bottom: 15px;">
                <label>Link to bibliography references:</label>
                <div id="segmentReferencesChecklist" style="max-height: 200px; overflow-y: auto; border: 1px solid #ccc; padding:10px;">
                    <p>Loading list of reference...</p>
                </div>
            </div>

            <button type="submit">Save segment</button>
            <button type="button" onclick="closeSegmentCreationModal()" style="background-color:#ccc;">Cancel</button>
        </form>
    </div>
</div>

{# *** MODAL WINDOW FOR ADDING A NEW SECTION *** #}
<div id="addSectionModal" style="display:none; position:fixed; flex-direction: column; z-index:1050; left:0; top:0; width:100%; height:100%; overflow:auto; background-color:rgba(0,0,0,0.4);">
    <div style="background-color:#fefefe; margin:auto; padding:20px; border:1px solid #888; width:60%; max-width:600px; border-radius:5px;">
        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 20px;">
            <h3 style="flex: 1; margin: 0;">Add new section</h3>

            <button onclick="closeAddSectionModal()" type="button" class="modal-toggle-button" isnotchangabletext="">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M6.4 19L5 17.6L10.6 12L5 6.4L6.4 5L12 10.6L17.6 5L19 6.4L13.4 12L19 17.6L17.6 19L12 13.4L6.4 19Z" fill="black"></path>
                </svg>
            </button>
        </div>

        <form id="addSectionForm">
            <p>
                <label for="newSectionTitle">New section title:</label>
                <input type="text" id="newSectionTitle" name="title" required>
            </p>

            <p>
                <label for="newSectionText">Text of the new section:</label>
                <textarea id="newSectionText" name="text" rows="5" style="width: calc(100% - 22px); padding:10px; border:1px solid #ddd;" required></textarea>
            </p>

            <button type="submit">Save section</button>
            <button type="button" onclick="closeAddSectionModal()" style="background-color:#ccc;">Cancel</button>
        </form>
    </div>
</div>

<div id="editReferenceModal" style="display:none; position:fixed; flex-direction: column; z-index:1000; left:0; top:0; width:100%; height:100%; overflow:auto; background-color:rgba(0,0,0,0.4);">
    <div style="background-color:#fefefe; margin:auto; padding:20px; border:1px solid #888; width:60%; max-width:600px; border-radius:5px;">
        <div style="display: flex; gap: 10px; align-items: center;">
            <h3 style="flex:1 ; margin: 0;">Edit reference</h3>

            <button onclick="closeEditModal()" type="button" class="modal-toggle-button" isnotchangabletext="">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M6.4 19L5 17.6L10.6 12L5 6.4L6.4 5L12 10.6L17.6 5L19 6.4L13.4 12L19 17.6L17.6 19L12 13.4L6.4 19Z" fill="black"></path>
                </svg>
            </button>
        </div>

        <form id="editReferenceForm">
            <input type="hidden" id="editRefId" name="id">

            <p>
                <label for="editRefRawText">Reference Text (Raw):</label>
                <textarea id="editRefRawText" name="raw_reference_text" rows="3" style="width: calc(100% - 22px); padding:10px; border:1px solid #ddd;"></textarea>
            </p>

            <p>
                <label for="editRefTargetDoi">Target DOI:</label>
                <input type="text" id="editRefTargetDoi" name="target_article_doi" placeholder="10.xxxx/xxxxx">
            </p>

            <p>
                <label for="editRefManualTitle">Title (from Manual Data):</label>
                <input type="text" id="editRefManualTitle" name="manual_title" placeholder="Title of the article being cited">
            </p>

            <p>
                <label for="editRefManualYear">Year (from Manual Data):</label>
                <input type="text" id="editRefManualYear" name="manual_year" placeholder="ГГГГ">
            </p>

            <p>
                <label for="editRefStatus">Status (current: <span id="currentRefStatusDisplay"></span>):</label>
                <select id="editRefStatus" name="status">
                    {% for value, display_name in ref_status_choices %} {# Pass ref_status_choices to context #}
                        <option value="{{ value }}">{{ display_name }}</option>
                    {% endfor %}
                </select>
            </p>

            <button type="submit">Save changes</button>
            <button type="button" onclick="closeEditModal()" style="background-color:#ccc;">Cancel</button>
        </form>
    </div>
</div>
{% endblock %}


{% block extra_js %}
<script>
// Получаем данные из тега script, созданного json_script
// Получаем начальное состояние structured_content
const structuredContentElement = document.getElementById('initial-structured-content-data');
let initialArticleStructuredContent = JSON.parse(structuredContentElement.textContent || '{}');

// Получаем данные о ссылках из тега script, созданного json_script
const refsDataElement = document.getElementById('article-references-data-script');
const articleReferencesDataForModal = JSON.parse(refsDataElement.textContent || '[]');
// articleReferencesDataForModal будет массивом массивов: [[pk, doi, raw_text, manual_data_json_object_or_null], ...]

// Получаем данные из тега script, созданного json_script
//const structuredContentElement = document.getElementById('initial-structured-content-data');
//let initialArticleStructuredContent = JSON.parse(structuredContentElement.textContent || '{}');

//const initialArticleStructuredContent = JSON.parse(document.getElementById('initial-structured-content-data').textContent || '{}');
//const articleReferencesData = JSON.parse(document.getElementById('article-references-data').textContent || '[]');

// --- JavaScript для создания анализируемого сегмента ---
const createSegmentBtn = document.getElementById('createSegmentBtn');
const segmentCreationModal = document.getElementById('segmentCreationModal');
const segmentCreationForm = document.getElementById('segmentCreationForm');
const segmentSectionKeyInput = document.getElementById('segmentSectionKey');
const segmentTextInput = document.getElementById('segmentText');
const segmentInlineCitationsInput = document.getElementById('segmentInlineCitations');
const segmentReferencesChecklistDiv = document.getElementById('segmentReferencesChecklist');
const articleIdForSegments = "{{ article.pk }}";

//const initialArticleStructuredContent = JSON.parse(document.getElementById('initial-structured-content-data').textContent || '{}');
const addSectionModal = document.getElementById('addSectionModal');
const addSectionForm = document.getElementById('addSectionForm');
const newSectionTitleInput = document.getElementById('newSectionTitle');
const newSectionTextInput = document.getElementById('newSectionText');

function closeAddSectionModal() {
    if (addSectionModal) addSectionModal.style.display = 'none';
}

// --- JavaScript для модального окна добавления новой ССЫЛКИ ---
const addReferenceModal = document.getElementById('addReferenceModal');
const addReferenceForm = document.getElementById('addReferenceForm');


// Показываем/скрываем кнопку "Создать сегмент" при выделении текста
document.addEventListener('mouseup', function(event) {
    const selection = window.getSelection();
    if (selection.toString().trim().length > 5) { // Показываем кнопку, если выделено больше 5 символов
        // Проверяем, что выделение не внутри модального окна или textarea
        let parent = selection.anchorNode;
        while (parent != null && parent !== document.body) {
            if (parent.id === 'segmentCreationModal' || parent.id === 'editReferenceModal' || parent.id === 'addSectionModal' || parent.tagName === 'TEXTAREA' || parent.tagName === 'INPUT') {
                createSegmentBtn.style.display = 'none';
                return;
            }
            parent = parent.parentNode;
        }
        createSegmentBtn.style.display = 'block';
    } else {
        // Не скрываем кнопку сразу, если клик был не по ней (чтобы можно было нажать)
        if (event.target !== createSegmentBtn && !createSegmentBtn.contains(event.target)) {
                createSegmentBtn.style.display = 'none';
        }
    }
});


if (createSegmentBtn) {
    createSegmentBtn.addEventListener('click', function() {
        const selectedText = window.getSelection().toString().trim();
        if (selectedText) {
            segmentTextInput.value = selectedText;
            // Пытаемся определить секцию, откуда был выделен текст (упрощенно)
            let parentElement = window.getSelection().anchorNode;
            let sectionKeyGuess = '';
            while(parentElement && parentElement !== document.body) {
                if(parentElement.id && parentElement.id.startsWith('section-')) {
                    sectionKeyGuess = parentElement.id.replace('section-', '');
                    break;
                } else if (parentElement.classList && parentElement.classList.contains('section-editor')) {
                    const h4 = parentElement.querySelector('h4 .edit-section-btn');
                    if (h4 && h4.dataset.section) sectionKeyGuess = h4.dataset.section;
                    else { // Для other_sections
                        const h5 = parentElement.querySelector('h5');
                        if(h5) sectionKeyGuess = h5.textContent.trim();
                    }
                    break;
                }
                parentElement = parentElement.parentNode;
            }
            segmentSectionKeyInput.value = sectionKeyGuess;

            populateReferencesChecklist();
            segmentCreationModal.style.display = 'flex';
        }
        this.style.display = 'none'; // Скрываем кнопку после открытия модала
    });
}


function closeSegmentCreationModal() {
    if (segmentCreationModal) segmentCreationModal.style.display = 'none';
}


function populateReferencesChecklist() {
    segmentReferencesChecklistDiv.innerHTML = '';
    if (articleReferencesDataForModal.length === 0) {
        segmentReferencesChecklistDiv.innerHTML = '<p>There are no references for this article.</p>';
        return;
    }
    articleReferencesDataForModal.forEach(ref_data_array => {
        // ref_data_array это [pk, target_article_doi, raw_reference_text, manual_data_json]
        const ref_pk = ref_data_array[0];
        const ref_doi = ref_data_array[1];
        const ref_raw_text = ref_data_array[2];
        const ref_manual_data = ref_data_array[3] || {}; // manual_data_json may be null

        let refLabelText = `ID: ${ref_pk}`;
        if (ref_doi) {
            refLabelText += ` (DOI: ${ref_doi})`;
        } else if (ref_manual_data && ref_manual_data.title) { // Checking that ref_manual_data is not null
            refLabelText += ` (${String(ref_manual_data.title).substring(0,50)}...)`;
        } else if (ref_raw_text) {
            refLabelText += ` (${String(ref_raw_text).substring(0,50)}...)`;
        }

        const checkboxId = `ref-check-${ref_pk}`;
        const div = document.createElement('div');
        div.innerHTML = `<input type="checkbox" id="${checkboxId}" name="cited_references" value="${ref_pk}">
                            <label for="${checkboxId}">${refLabelText}</label>`;
        segmentReferencesChecklistDiv.appendChild(div);
    });
}


if (segmentCreationForm) {
    segmentCreationForm.addEventListener('submit', function(event) {
        event.preventDefault();
        const selectedReferenceIds = Array.from(segmentCreationForm.querySelectorAll('input[name="cited_references"]:checked'))
                                        .map(cb => parseInt(cb.value, 10));
        const inlineMarkersText = segmentInlineCitationsInput.value.trim();
        const inlineMarkersArray = inlineMarkersText ? inlineMarkersText.split(',').map(s => s.trim()).filter(s => s) : [];

        const payload = {
            article_id: articleIdForSegments,
            section_key: segmentSectionKeyInput.value.trim() || null,
            segment_text: segmentTextInput.value.trim(),
            inline_citation_markers: inlineMarkersArray,
            cited_references: selectedReferenceIds
        };

        if (!payload.segment_text) {
            alert("Segment text cannot be empty.");
            return;
        }

        const saveButton = segmentCreationForm.querySelector('button[type="submit"]');
        saveButton.disabled = true;
        saveButton.textContent = 'Saving...';

        addNotificationToDetail(
            {
                payload: {
                    status: 'INFO',
                    message: `Saving a new segment...`,
                    identifier: `ArticleID:${articleIdForSegments}`
                }
            }
        );

        fetch(`/api/articles/analyzed-segments/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': getCSRFToken(), 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(response => response.json().then(data => ({ok: response.ok, status_code: response.status, data})))
        .then(({ok, status_code, data}) => {
            if (ok && (status_code === 201 || status_code === 200)) { // 201 Created
                addNotificationToDetail(
                    {
                        payload: {
                            status: 'SUCCESS',
                            message: `Segment successfully created (ID: ${data.id}).`
                        }
                    }
                );
                closeSegmentCreationModal();
                window.location.reload(); // To update the list of segments
            } else {
                let errorMessage = `Error creating segment (${status_code}): `;
                if (data) {
                    for (const field in data) {
                        errorMessage += `${field}: ${Array.isArray(data[field]) ? data[field].join(', ') : data[field]} `;
                    }
                }
                else {
                    errorMessage += "Unknown server error."
                }
                addNotificationToDetail(
                    {
                        payload: {
                            status: 'FAILURE',
                            message: errorMessage,
                            identifier: `ArticleID:${articleIdForSegments}`
                        }
                    }
                );
            }
        })
        .catch(error => {
            console.error('Error creating segment:', error);
            addNotificationToDetail(
                {
                    payload: {
                        status: 'FAILURE',
                        message: `Network error: ${error.message}`,
                        identifier: `ArticleID:${articleIdForSegments}`
                    }
                }
            );
        })
        .finally(() => {
            if(saveButton) {
                saveButton.disabled = false;
                saveButton.textContent = 'Save segment';
            }
        });
    });
}


function toggleRawContent(element, contentId) {
    const contentDiv = document.getElementById(contentId);
    if (contentDiv.style.display === "none" || contentDiv.style.display === "") {
        contentDiv.style.display = "block";
        element.textContent = "Hide data";
    } else {
        contentDiv.style.display = "none";
        element.textContent = "Show data";
    }
}


const notificationsDiv = document.getElementById('notifications');
const currentUserIdForWS = "{{ user_id }}"; // From the Django context

// --- WebSocket for notifications ---
let ws_protocol_detail = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
let ws_url_detail = `${ws_protocol_detail}//${window.location.host}/ws/notifications/`;
let socket_detail;


function connectWebSocketDetail() {
    if (!currentUserIdForWS || currentUserIdForWS === 'None') return;

    socket_detail = new WebSocket(ws_url_detail);

    socket_detail.onopen = function(e) {
        console.log("WebSocket (detail page) connection established.");
    };

    socket_detail.onmessage = function(event) {
        const data = JSON.parse(event.data);
        console.log("Received WebSocket (detail page) message:", data);
        // Фильтруем уведомления, чтобы показать только те, что относятся к текущей статье, если это возможно.
        // Например, если бы payload содержал article_id, по которому можно фильтровать.
        // В текущей реализации send_user_notification не передает ID статьи-источника уведомления.
        // Пока что будут отображаться все уведомления для пользователя.
        addNotificationToDetail(data);
    };

    socket_detail.onclose = function(event) {
        console.error('WebSocket (detail page) connection closed:', event);
        setTimeout(connectWebSocketDetail, 5000);
    };

    socket_detail.onerror = function(error) {
        console.error('WebSocket (detail page) error:', error);
    };
}


function addNotificationToDetail(data) {
    const notificationsContainer = document.getElementById('notifications');
    const initialMsg = notificationsContainer.querySelector('p[style*="text-align: center"]');

    if (initialMsg) {
        initialMsg.remove(); // Remove the startup message "Waiting for notifications..."
    }

    let notificationHtml = `<div class="status-${data.payload?.status || 'INFO'}">`;

    if (data.type === 'connection_established') {
        notificationHtml += `<strong>${data.message || data.payload?.message}</strong>`;
    } else if (data.type === 'task_notification' && data.payload) {
        const p = data.payload;
        notificationHtml += `<strong>Task [${p.task_id || 'N/A'}] for ${p.source_api || 'Source'} (${p.identifier || 'N/A'})</strong><br>`;
        notificationHtml += `Status: ${p.status}<br>`;
        notificationHtml += `Message: ${p.message}<br>`;
        if (p.progress_percent !== undefined) {
            notificationHtml += `Progress: ${p.progress_percent}%<br>`;
        }
        if (p.article_id) {
            notificationHtml += `Article ID: ${p.article_id} (Created: ${p.created === undefined ? 'N/A' : p.created})<br>`;
        }
    } else if (data.payload) {
         notificationHtml += `<strong>${data.payload.source_api || 'System'} (${data.payload.identifier || 'N/A'})</strong><br>`;
         notificationHtml += `Status: ${data.payload.status}<br>`;
         notificationHtml += `Message: ${data.payload.message}<br>`;
         if (data.payload.progress_percent !== undefined) {
            notificationHtml += `Progress: ${data.payload.progress_percent}%<br>`;
        }
    } else {
        notificationHtml += JSON.stringify(data);
    }
    notificationHtml += `</div>`;
    notificationsContainer.insertAdjacentHTML('afterbegin', notificationHtml);
}


connectWebSocketDetail(); // Connect when the page loads


function getCSRFToken() {
    // Looking for a token in a fictitious form
    const csrfInput = document.querySelector('form[style="display:none;"] input[name="csrfmiddlewaretoken"]');
    if (csrfInput) {
        return csrfInput.value;
    }
    // Looking in cookies
    const cookies = document.cookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.startsWith('csrftoken=')) {
            return cookie.substring('csrftoken='.length, cookie.length);
        }
    }
    return '';
}


function loadReferencedArticle(referenceLinkId, buttonElement) {
    if (!referenceLinkId) return;

    // Temporarily disable the button to avoid double clicks
    buttonElement.disabled = true;
    buttonElement.textContent = 'Loading...';

    const apiUrl = `/api/articles/reference-links/${referenceLinkId}/load-article/`;

    addNotificationToDetail({
        payload: {
            status: 'INFO',
            message: `Submitting a request to download an article for a link ID ${referenceLinkId}...`,
            identifier: `RefLinkID:${referenceLinkId}`
        }
    });

    fetch(apiUrl, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCSRFToken(), // for POST requests in Django
            'Content-Type': 'application/json'
        },
        // body: JSON.stringify({})
    })
    .then(response => {
        // Восстанавливаем кнопку после получения ответа, кроме случая, если ссылка уже была обработана (200 OK с info)
        if (response.status !== 200 || !response.headers.get("content-type")?.includes("application/json")) {
             // Если это не успешный info, который говорит что уже обработано, то можно разблокировать
             // Но лучше оставить заблокированной, т.к. статус обновится через WebSocket и кнопка исчезнет/станет неактивной
        }
        return response.json().then(data => ({ ok: response.ok, status: response.status, data }));
    })
    .then(({ ok, status, data }) => {
        console.log('Response from API load-referenced-article:', data);
        if (ok) { // 200, 201, 202
            if (data.info) { // Если сервер сообщил, что статья уже связана
                addNotificationToDetail({
                    payload: {
                        status: 'INFO',
                        message: data.info,
                        identifier: `RefLinkID:${referenceLinkId}`
                    }
                });
                buttonElement.textContent = 'Already loaded';
                buttonElement.disabled = true;
            } else {
                addNotificationToDetail({
                    payload: {
                        status: 'SUCCESS',
                        message: data.message || `Load request for link ID ${referenceLinkId} sent successfully`,
                        identifier: `RefLinkID:${referenceLinkId}`
                    }
                });
                // Кнопка может оставаться disabled, т.к. статус ссылки обновится через WebSocket
                // и она либо исчезнет, либо станет неактивной в шаблоне при перезагрузке
                buttonElement.textContent = 'In processing';
            }
        } else {
            addNotificationToDetail({
                payload: {
                    status: 'FAILURE',
                    message: `Error (${status}): ${data.error || JSON.stringify(data)}`, identifier: `RefLinkID:${referenceLinkId}`
                }
            });
            buttonElement.disabled = false;
            buttonElement.textContent = 'Download by DOI';
        }
    })
    .catch(error => {
        console.error('Error while calling API load-referenced-article:', error);
        addNotificationToDetail({
            payload: {
                status: 'FAILURE',
                message: `Network error or parsing error: ${error.message}`, identifier: `RefLinkID:${referenceLinkId}`
            }
        });
        buttonElement.disabled = false;
        buttonElement.textContent = 'Download by DOI';
    });
}


function findDoiForReference(referenceLinkId, buttonElement) {
    if (!referenceLinkId) return;

    buttonElement.disabled = true;
    buttonElement.textContent = 'Search DOI...';

    const apiUrl = `/api/articles/reference-links/${referenceLinkId}/find-doi/`;

    addNotificationToDetail({
        payload: {
            status: 'INFO',
            message: `Submitting a DOI lookup request for a reference ID ${referenceLinkId}...`,
            identifier: `RefLinkID:${referenceLinkId}` // Use the reference ID as an identifier for the notification
        }
    });

    fetch(apiUrl, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCSRFToken(),
            'Content-Type': 'application/json'
        },
    })
    .then(response => response.json().then(data => ({ ok: response.ok, status: response.status, data })))
    .then(({ ok, status, data }) => {
        console.log('Response from API find-doi-for-reference:', data);
        if (ok) {
            addNotificationToDetail({
                payload: {
                    status: 'SUCCESS',
                    message: data.message || `Запрос на поиск DOI для ссылки ID ${referenceLinkId} успешно отправлен.`,
                    identifier: `RefLinkID:${referenceLinkId}`
                }
            });
            // Кнопка может оставаться disabled, т.к. статус ссылки обновится через WebSocket
            // и она либо исчезнет (если DOI найден), либо изменит текст/состояние.
            buttonElement.textContent = 'In search'; // Временно
        } else {
            addNotificationToDetail({
                payload: {
                    status: 'FAILURE', message: `Ошибка (${status}): ${data.error || data.info || JSON.stringify(data)}`,
                    identifier: `RefLinkID:${referenceLinkId}`
                }
            });
            buttonElement.disabled = false; // Unlock the button if there is an error
            buttonElement.textContent = 'Find DOI';
        }
    })
    .catch(error => {
        console.error('Error while calling API find-doi-for-reference:', error);
        addNotificationToDetail({
            payload: {
                status: 'FAILURE',
                message: `Network error or parsing error: ${error.message}`,
                identifier: `RefLinkID:${referenceLinkId}`
            }
        });
        buttonElement.disabled = false;
        buttonElement.textContent = 'Find DOI';
    });
}


function findAllReferenceDois(articleId, buttonElement) {
    if (!articleId) return;

    buttonElement.disabled = true;
    buttonElement.textContent = 'Starting a search...';

    const apiUrl = `/api/articles/articles/${articleId}/find-all-reference-dois/`;

    addNotificationToDetail({
        payload: {
            status: 'INFO',
            message: `Submitting a Bulk DOI Search Request for an Article ID ${articleId}...`,
            identifier: `ArticleID:${articleId}`
        }
    });

    fetch(apiUrl, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCSRFToken(),
            'Content-Type': 'application/json'
        },
    })
    .then(response => response.json().then(data => ({ ok: response.ok, status: response.status, data })))
    .then(({ ok, status, data }) => {
        console.log('Response from API find-all-reference-dois:', data);
        if (ok) { // 200, 202
            addNotificationToDetail({
                payload: {
                    status: 'SUCCESS', message: data.message || `Multiple DOI search started.`,
                    identifier: `ArticleID:${articleId}`
                }
            });
        } else {
            addNotificationToDetail({
                payload: {
                    status: 'FAILURE',
                    message: `Error (${status}): ${data.error || data.info || JSON.stringify(data)}`,
                    identifier: `ArticleID:${articleId}`
                }
            });
        }
        // Кнопку можно оставить disabled или обновить текст, т.к. отдельные задачи будут обновлять UI через WebSocket
        buttonElement.textContent = 'Search started';
        // Можно добавить логику для повторной активации кнопки через некоторое время или по условию
        // setTimeout(() => {
        //     buttonElement.disabled = false;
        //     buttonElement.textContent = 'Найти DOI для всех ненайденных';
        // }, 5000); // Например, через 5 секунд
    })
    .catch(error => {
        console.error('Error while calling API find-all-reference-dois:', error);
        addNotificationToDetail({
            payload: {
                status: 'FAILURE',
                message: `Network error or parsing error: ${error.message}`,
                identifier: `ArticleID:${articleId}`
            }
        });
        buttonElement.disabled = false;
        buttonElement.textContent = 'Find DOI for all unfound';
    });
}


const editModal = document.getElementById('editReferenceModal');
const editForm = document.getElementById('editReferenceForm');
const editRefIdInput = document.getElementById('editRefId');
const editRefRawTextInput = document.getElementById('editRefRawText');
const editRefTargetDoiInput = document.getElementById('editRefTargetDoi');
const editRefManualTitleInput = document.getElementById('editRefManualTitle');
const editRefManualYearInput = document.getElementById('editRefManualYear');
const editRefStatusSelect = document.getElementById('editRefStatus');
const currentRefStatusDisplaySpan = document.getElementById('currentRefStatusDisplay');


function openEditModal(refId, rawText, targetDoi, manualTitle, manualYear, currentStatus, currentStatusDisplay) {
    editRefIdInput.value = refId;
    editRefRawTextInput.value = rawText || ''; // not 'None' or 'undefined'
    editRefTargetDoiInput.value = targetDoi || '';
    editRefManualTitleInput.value = manualTitle || '';
    editRefManualYearInput.value = manualYear || '';
    editRefStatusSelect.value = currentStatus || '';
    currentRefStatusDisplaySpan.textContent = currentStatusDisplay || 'N/A';

    editModal.style.display = 'flex';
}


function closeEditModal() {
    editModal.style.display = 'none';
}


editForm.addEventListener('submit', function(event) {
    event.preventDefault();
    const refId = editRefIdInput.value;

    // Собираем данные из формы, manual_data_json должен быть объектом
    const manualData = {
        title: editRefManualTitleInput.value.trim() || null,
        year: editRefManualYearInput.value.trim() || null,
        // Сохраняем существующие поля manual_data_json, если они были, и перезаписываем только эти
        // Это потребует загрузки текущего manual_data_json при открытии модала, если оно сложнее
    };

    // Чтобы не потерять другие поля в manual_data_json, которые не редактируются в этой форме,
    // лучше загружать полный manual_data_json при открытии модала и затем обновлять его.
    // Для простоты сейчас мы создаем его заново с полями из формы.
    // Если manual_data_json может содержать и другие ключи, то потребуется более сложная логика.

    const payload = {
        raw_reference_text: editRefRawTextInput.value.trim(),
        target_article_doi: editRefTargetDoiInput.value.trim() || null, // Отправляем null, если пусто
        manual_data_json: manualData,
        status: editRefStatusSelect.value // Пользователь может изменить статус, если это разрешено
    };

    // Удаляем null значения из manualData, чтобы не засорять JSON
    for (const key in payload.manual_data_json) {
        if (payload.manual_data_json[key] === null || payload.manual_data_json[key] === '') {
            delete payload.manual_data_json[key];
        }
    }
    if (Object.keys(payload.manual_data_json).length === 0) {
        payload.manual_data_json = null; // Если объект пуст, отправляем null
    }

    const apiUrl = `/api/articles/referencelinks/${refId}/`;

    addNotificationToDetail({
        payload: {
            status: 'INFO',
            message: `Saving changes to reference ID ${refId}...`,
            identifier: `RefLinkID:${refId}`
        }
    });

    fetch(apiUrl, {
        method: 'PATCH',
        headers: {
            'X-CSRFToken': getCSRFToken(),
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
    })
    .then(response => response.json().then(data => ({ ok: response.ok, status: response.status, data })))
    .then(({ ok, status, data }) => {
        if (ok) {
            addNotificationToDetail({
                payload: {
                    status: 'SUCCESS',
                    message: `Reference ID ${refId} successfully updated.`,
                    identifier: `RefLinkID:${refId}`
                }
            });
            closeEditModal();
            // Перезагрузка страницы для отображения изменений - самый простой способ
            // Либо более сложный JS для обновления конкретной ссылки в списке на лету
            window.location.reload();
        } else {
            let errorMessage = `Error (${status}): `;
            if (data) {
                for (const field in data) {
                    errorMessage += `${field}: ${data[field].join ? data[field].join(', ') : data[field]} `;
                }
            } else {
                errorMessage += "Unknown server error."
            }
            addNotificationToDetail({
                payload: {
                    status: 'FAILURE',
                    message: errorMessage,
                    identifier: `RefLinkID:${refId}`
                }
            });
        }
    })
    .catch(error => {
        console.error('Error updating ReferenceLink:', error);
        addNotificationToDetail({
            payload: {
                status: 'FAILURE',
                message: `Network error or parsing error: ${error.message}`,
                identifier: `RefLinkID:${refId}`
            }
        });
    });
});


function loadAllLinkedReferences(articleId, buttonElement) {
    if (!articleId) return;

    buttonElement.disabled = true;
    buttonElement.textContent = 'Starting the download...';

    const apiUrl = `/api/articles/articles/${articleId}/load-all-linked-references/`;

    addNotificationToDetail({
        payload: {
            status: 'INFO',
            message: `Sending a request for bulk download of articles by links for article ID ${articleId}...`,
            identifier: `ArticleID:${articleId}`
        }
    });

    fetch(apiUrl, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCSRFToken(),
            'Content-Type': 'application/json'
        },
    })
    .then(response => response.json().then(data => ({ ok: response.ok, status: response.status, data })))
    .then(({ ok, status, data }) => {
        console.log('Response from API load-all-linked-references:', data);
        if (ok) { // 200, 202
            addNotificationToDetail({
                payload: {
                    status: 'SUCCESS',
                    message: data.message || `Loading of articles via references has started.`,
                    identifier: `ArticleID:${articleId}`
                }
            });
        } else {
            addNotificationToDetail({
                payload: {
                    status: 'FAILURE',
                    message: `Error (${status}): ${data.error || data.info || JSON.stringify(data)}`,
                    identifier: `ArticleID:${articleId}`
                }
            });
        }
        buttonElement.textContent = 'Download started';
        // Можно добавить логику для повторной активации кнопки через некоторое время
        // setTimeout(() => {
        //     buttonElement.disabled = false;
        //     buttonElement.textContent = 'Загрузить все с DOI';
        // }, 10000); // Например, через 10 секунд
    })
    .catch(error => {
        console.error('Error while calling API load-all-linked-references:', error);
        addNotificationToDetail({
            payload: {
                status: 'FAILURE',
                message: `Network error or parsing error: ${error.message}`,
                identifier: `ArticleID:${articleId}`
            }
        });
        buttonElement.disabled = false;
        buttonElement.textContent = 'Download all with DOI';
    });
}


function reprocessArticle(articleId, buttonElement) {
    if (!articleId) return;

    if (!confirm("Are you sure you want to reprocess this article? Existing data may be updated.")) {
        return;
    }

    buttonElement.disabled = true;
    buttonElement.textContent = 'Reprocessing...';

    const apiUrl = `/api/articles/articles/${articleId}/reprocess/`;

    addNotificationToDetail({
        payload: {
            status: 'INFO',
            message: `Submitting a request to reprocess an article ID ${articleId}...`,
            identifier: `ArticleID:${articleId}`
        }
    });

    fetch(apiUrl, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCSRFToken(),
            'Content-Type': 'application/json'
        },
    })
    .then(response => response.json().then(data => ({ ok: response.ok, status: response.status, data })))
    .then(({ ok, status, data }) => {
        console.log('Response from API reprocess-article:', data);
        if (ok) { // 202 Accepted
            addNotificationToDetail({
                payload: {
                    status: 'SUCCESS', message: data.message || `Request to reprocess article ID ${articleId} successfully sent.`, identifier: `ArticleID:${articleId}`
                }
            });
        } else {
            addNotificationToDetail({
                payload: {
                    status: 'FAILURE',
                    message: `Error (${status}): ${data.error || JSON.stringify(data)}`,
                    identifier: `ArticleID:${articleId}`
                }
            });
        }
        // Кнопку можно оставить disabled или обновить текст, т.к. WebSocket покажет дальнейший прогресс
        buttonElement.textContent = 'In processing';
        // setTimeout(() => { buttonElement.disabled = false; buttonElement.textContent = 'Переобработать статью'; }, 5000);
    })
    .catch(error => {
        console.error('Error while calling API reprocess-article:', error);
        addNotificationToDetail({
            payload: {
                status: 'FAILURE',
                message: `Network error or parsing error: ${error.message}`,
                identifier: `ArticleID:${articleId}`
            }
        });
        buttonElement.disabled = false;
        buttonElement.textContent = 'Rework the article';
    });
}


function deleteArticle(articleId, buttonElement) {
    if (!articleId) return;

    if (!confirm("Are you sure you want to delete this article and all data associated with it? This action is irreversible.")) {
        return;
    }

    buttonElement.disabled = true;
    buttonElement.textContent = 'Delete...';

    // Стандартный DRF endpoint для удаления объекта
    const apiUrl = `/api/articles/articles/${articleId}/`;

    addNotificationToDetail({
        payload: {
            status: 'INFO',
            message: `Submitting a request to delete an article ID ${articleId}...`,
            identifier: `ArticleID:${articleId}`
        }
    });

    fetch(apiUrl, {
        method: 'DELETE',
        headers: {
            'X-CSRFToken': getCSRFToken(),
            // 'Content-Type': 'application/json' // DELETE обычно не требует Content-Type и body
        },
    })
    .then(response => {
        if (response.status === 204) { // 204 No Content - successful deleted
            return { ok: true, status: response.status, data: { message: "The article has been successfully deleted." } };
        }
        // If there is a response body with an error
        return response.json().then(data => ({ ok: response.ok, status: response.status, data }));
    })
    .then(({ ok, status, data }) => {
        console.log('Ответ от API delete-article:', data);
        if (ok) { // 204 No Content
            addNotificationToDetail({
                payload: {
                    status: 'SUCCESS',
                    message: data.message || `Article ID ${articleId} successfully deleted. Redirecting to the list of articles...`,
                    identifier: `ArticleID:${articleId}`
                }
            });
            window.location.href = "{% url 'article_list' %}"; // Redirect to the list of articles after successful deletion
        } else {
            addNotificationToDetail({
                payload: {
                    status: 'FAILURE',
                    message: `Error deleting (${status}): ${data.error || data.detail || JSON.stringify(data)}`,
                    identifier: `ArticleID:${articleId}`
                }
            });
            buttonElement.disabled = false;
            buttonElement.textContent = 'Delete article';
        }
    })
    .catch(error => {
        console.error('Error while calling API delete-article:', error);
        addNotificationToDetail({
            payload: {
                status: 'FAILURE',
                message: `Network error or parsing error while deleting: ${error.message}`,
                identifier: `ArticleID:${articleId}`
            }
        });
        buttonElement.disabled = false;
        buttonElement.textContent = 'Delete article';
    });
}


document.addEventListener('DOMContentLoaded', function() {

    document.querySelectorAll('.edit-section-btn').forEach(button => {
        button.addEventListener('click', function() {
            const sectionKey = this.dataset.section;
            const displayDiv = document.getElementById(`display-${sectionKey}`);
            const formDiv = document.getElementById(`form-${sectionKey}`);
            const textarea = document.getElementById(`textarea-${sectionKey}`);

            // Скрываем отображение текста и кнопку "Редактировать"
            displayDiv.style.display = 'none';
            this.style.display = 'none';

            // Показываем форму редактирования
            formDiv.style.display = 'block';

            // ЗАПОЛНЯЕМ TEXTAREA из initialArticleStructuredContent
            // Это гарантирует, что мы берем текст конкретной секции, как он был загружен с сервера,
            // или пустоту, если для этой секции текста не было.
            textarea.value = initialArticleStructuredContent[sectionKey] || ""; // Если ключа нет или значение null/undefined, будет пустая строка

            textarea.focus();
        });
    });

    document.querySelectorAll('.cancel-section-btn').forEach(button => {
        button.addEventListener('click', function() {
            const sectionKey = this.dataset.section;
            document.getElementById(`form-${sectionKey}`).style.display = 'none';
            document.getElementById(`display-${sectionKey}`).style.display = 'block';
            document.querySelector(`.edit-section-btn[data-section="${sectionKey}"]`).style.display = 'inline-block';
        });
    });

    // Обработчик для .save-section-btn (использует initialArticleStructuredContent для формирования payload)
    document.querySelectorAll('.save-section-btn').forEach(button => {
        button.addEventListener('click', function() {
            const sectionKey = this.dataset.section;
            const newText = document.getElementById(`textarea-${sectionKey}`).value.trim();
            const articleId = "{{ article.pk }}";

            // Создаем глубокую копию initialArticleStructuredContent (или текущего состояния, если вы его обновляете в JS)
            // и обновляем только нужную секцию
            let payloadStructuredContent = JSON.parse(JSON.stringify(initialArticleStructuredContent || {}));

            if (newText) {
                payloadStructuredContent[sectionKey] = newText;
            } else {
                // Если текст пустой, удаляем ключ из объекта, чтобы на бэкенде секция тоже очистилась или удалилась
                // (зависит от того, как ваш бэкенд обрабатывает отсутствие ключа при PATCH)
                // Если хотите передать пустую строку, то: payloadStructuredContent[sectionKey] = "";
                delete payloadStructuredContent[sectionKey];
            }

            const payload = {
                structured_content: payloadStructuredContent
            };

            button.disabled = true;
            button.textContent = 'Saving...';

            addNotificationToDetail({
                payload: {
                    status: 'INFO',
                    message: `Saving a section "${sectionKey}"...`,
                    identifier: `ArticleID:${articleId}`
                }
            });

            fetch(`/api/articles/articleuser/${articleId}/`, {
                method: 'PATCH',
                headers: {
                    'X-CSRFToken': getCSRFToken(),
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            })
            .then(response => response.json().then(data => ({ok: response.ok, status_code: response.status, data})))
            .then(({ok, status_code, data}) => {
                if (ok) {
                    addNotificationToDetail({
                        payload: {
                            status: 'SUCCESS',
                            message: `Section "${sectionKey}" saved successfully.`
                        }
                    });
                    // Вместо обновления DOM вручную, перезагружаем страницу,
                    // чтобы все данные, включая initialArticleStructuredContent и cleaned_text_for_llm, были актуальны.
                    window.location.reload();
                } else {
                    let errorMessage = `Saving error (${status_code}): `;
                    if (data) {
                        for (const field in data) {
                            errorMessage += `${field}: ${Array.isArray(data[field]) ? data[field].join(', ') : data[field]} `;
                        }
                    } else { errorMessage += "Unknown server error." }
                    addNotificationToDetail({
                        payload: {
                            status: 'FAILURE',
                            message: errorMessage,
                            identifier: `ArticleID:${articleId}`
                        }
                    });
                    button.disabled = false; // Возвращаем кнопку в активное состояние при ошибке
                    button.textContent = 'Save';
                }
            })
            .catch(error => {
                console.error(`Error saving section ${sectionKey}:`, error);
                addNotificationToDetail({
                    payload: {
                        status: 'FAILURE',
                        message: `Network error: ${error.message}`,
                        identifier: `ArticleID:${articleId}`
                    }
                });
                button.disabled = false;
                button.textContent = 'Save';
            });
        });
    });

    // Функции теперь могут быть определены внутри DOMContentLoaded или на верхнем уровне,
    // так как они будут вызываться из слушателей, определенных в той же области видимости.
    function openAddSectionModal() {
        if (newSectionTitleInput) newSectionTitleInput.value = '';
        if (newSectionTextInput) newSectionTextInput.value = '';
        if (addSectionModal) addSectionModal.style.display = 'flex';
        if (newSectionTitleInput) newSectionTitleInput.focus();
    }


    // Слушатель для кнопки открытия модального окна
    const openModalButton = document.getElementById('openAddSectionModalBtn');
    if (openModalButton) {
        openModalButton.addEventListener('click', openAddSectionModal);
    }

    if (addSectionForm) { // Проверка на существование формы
        addSectionForm.addEventListener('submit', function(event) {
            event.preventDefault();
            const sectionTitle = newSectionTitleInput.value.trim();
            const sectionText = newSectionTextInput.value.trim();
            const articleId = "{{ article.pk }}";

            if (!sectionTitle || !sectionText) {
                alert("The section title and text cannot be empty.");
                return;
            }

            let payloadStructuredContent = JSON.parse(JSON.stringify(initialArticleStructuredContent || {}));

            if (!Array.isArray(payloadStructuredContent.other_sections)) {
                payloadStructuredContent.other_sections = [];
            }
            payloadStructuredContent.other_sections.push({
                title: sectionTitle,
                text: sectionText
            });

            const payload = { structured_content: payloadStructuredContent };
            const saveButton = addSectionForm.querySelector('button[type="submit"]');
            saveButton.disabled = true;
            saveButton.textContent = 'Saving...';

            addNotificationToDetail({
                payload: {
                    status: 'INFO',
                    message: `Adding a section "${sectionTitle}"...`,
                    identifier: `ArticleID:${articleId}`
                }
            });

            fetch(`/api/articles/articles/${articleId}/`, {
                method: 'PATCH',
                headers: { 'X-CSRFToken': getCSRFToken(), 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
            .then(response => response.json().then(data => ({ok: response.ok, status_code: response.status, data})))
            .then(({ok, status_code, data}) => {
                if (ok) {
                    addNotificationToDetail({
                        payload: {
                            status: 'SUCCESS',
                            message: `Section "${sectionTitle}" successfully added.`
                        }
                    });
                    closeAddSectionModal();
                    // Обновляем initialArticleStructuredContent глобально, если не перезагружаем
                    if (data && data.structured_content) { // Предполагаем, что API возвращает обновленный article или structured_content
                        initialArticleStructuredContent = data.structured_content;
                    }
                    window.location.reload(); // Перезагрузка
                } else {
                    // ... обработка ошибок ...
                    let errorMessage = `Error adding section (${status_code}): `;
                    if (data) {
                        for (const field in data) {
                            errorMessage += `${field}: ${Array.isArray(data[field]) ? data[field].join(', ') : data[field]} `;
                        }
                    }
                    else {
                        errorMessage += "Unknown server error."
                    }
                    addNotificationToDetail({
                        payload: {
                            status: 'FAILURE',
                            message: errorMessage,
                            identifier: `ArticleID:${articleId}`
                        }
                    });
                }
            })
            .catch(error => {
                addNotificationToDetail({
                    payload: {
                        status: 'FAILURE',
                        message: `Network error: ${error.message}`,
                        identifier: `ArticleID:${articleId}`
                    }
                });
            })
            .finally(() => {
                if (saveButton) {
                    saveButton.disabled = false;
                    saveButton.textContent = 'Save section';
                }
            });
        });
    }

    // Слушатели для кнопок удаления кастомных секций
    // Используем делегирование событий, если секции могут добавляться динамически без перезагрузки
    // Но так как у нас пока перезагрузка после добавления/редактирования, прямой поиск кнопок сработает.
    document.querySelectorAll('.delete-custom-section-btn').forEach(button => {
        button.addEventListener('click', function() {
            const sectionIndex = parseInt(this.dataset.sectionIndex, 10);
            const sectionTitle = this.dataset.sectionTitle || "this section";
            const articleId = "{{ article.pk }}";

            if (isNaN(sectionIndex)) {
                console.error("Invalid section index to delete.");
                addNotificationToDetail({
                    payload: {
                        status: 'FAILURE',
                        message: 'Error: Unable to determine the section to delete.'
                    }
                });
                return;
            }

            if (!confirm(`Are you sure you want to delete section "${sectionTitle}"? This action is irreversible.`)) {
                return;
            }

            // Создаем глубокую копию initialArticleStructuredContent
            let payloadStructuredContent = JSON.parse(JSON.stringify(initialArticleStructuredContent || {}));

            // Убеждаемся, что other_sections существует и является массивом
            if (payloadStructuredContent.other_sections && Array.isArray(payloadStructuredContent.other_sections)) {
                if (sectionIndex >= 0 && sectionIndex < payloadStructuredContent.other_sections.length) {
                    payloadStructuredContent.other_sections.splice(sectionIndex, 1); // Удаляем элемент по индексу
                } else {
                    console.error(`Section index ${sectionIndex} is out of range for other_sections.`);
                    addNotificationToDetail({
                        payload: {
                            status: 'FAILURE',
                            message: 'Error: Section to delete not found (invalid index).'
                        }
                    });
                    return;
                }
            } else {
                console.warn("Array 'other_sections' not found or is not an array in structured_content.");
                // Если other_sections нет, то и удалять нечего - это странная ситуация, если кнопка была нажата
                addNotificationToDetail({
                    payload: {
                        status: 'INFO',
                        message: 'There are no custom sections to delete..'
                    }
                });
                return;
            }

            const payload = {
                structured_content: payloadStructuredContent
            };

            this.disabled = true;
            this.textContent = 'Deleting...';

            addNotificationToDetail({
                payload: {
                    status: 'INFO',
                    message: `Deleting a section "${sectionTitle}"...`,
                    identifier: `ArticleID:${articleId}`
                }
            });

            fetch(`/api/articles/articles/${articleId}/`, {
                method: 'PATCH',
                headers: {
                    'X-CSRFToken': getCSRFToken(),
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            })
            .then(response => response.json().then(data => ({ok: response.ok, status_code: response.status, data})))
            .then(({ok, status_code, data}) => {
                if (ok) {
                    addNotificationToDetail({
                        payload: {
                            status: 'SUCCESS',
                            message: `Section "${sectionTitle}" successfully deleted.`
                        }
                    });

                    // Динамическое удаление HTML элемента секции со страницы
                    const sectionElementToRemove = document.getElementById(`custom-section-${sectionIndex}`);

                    if (sectionElementToRemove) {
                        sectionElementToRemove.remove();
                    }

                    // Обновляем наш локальный initialArticleStructuredContent, чтобы он был актуален
                    // если пользователь захочет удалить еще одну секцию без перезагрузки страницы.
                    if (data && data.structured_content) {
                        initialArticleStructuredContent = data.structured_content;
                    } else {
                        // Если API не вернул обновленный structured_content, берем наш измененный payload
                        initialArticleStructuredContent = payloadStructuredContent;
                    }
                    // Перезагрузка страницы для полной синхронизации (включая cleaned_text_for_llm) - более простой вариант
                    // window.location.reload();
                } else {
                    let errorMessage = `Error deleting section (${status_code}): `;
                    if (data) {
                        for (const field in data) {
                            errorMessage += `${field}: ${Array.isArray(data[field]) ? data[field].join(', ') : data[field]} `;
                        }
                    }
                    else {
                        errorMessage += "Unknown server error."
                    }

                    addNotificationToDetail({
                        payload: {
                            status: 'FAILURE',
                            message: errorMessage, identifier: `ArticleID:${articleId}`
                        }
                    });

                    this.disabled = false;
                    this.textContent = 'Delete this section';
                }
            })
            .catch(error => {
                console.error('Error deleting custom section:', error);
                addNotificationToDetail({
                    payload: {
                        status: 'FAILURE',
                        message: `Network error: ${error.message}`,
                        identifier: `ArticleID:${articleId}`
                    }
                });
                this.disabled = false;
                this.textContent = 'Delete this section';
            });
        });
    });

});


document.querySelectorAll('.llm-analyze-segment-btn').forEach(button => {
    button.addEventListener('click', function() {
        const segmentId = this.dataset.segmentId;
        if (!segmentId) return;

        const paramKey = 'segmentID';
        const paramValue = segmentId;

        const url = new URL(window.location);
        url.searchParams.set(paramKey, paramValue);

        history.replaceState(null, '', url);

        if (!confirm("Run LLM analysis for this segment? This may take some time.")) {
            return;
        }

        this.disabled = true;
        this.textContent = 'LLM Analysis...';

        const resultsDiv = document.getElementById(`llm-analysis-results-${segmentId}`);
        if (resultsDiv) {
             resultsDiv.innerHTML = '<p><strong>LLM Analysis:</strong> Запрос отправлен, ожидание...</p>';
        }

        addNotificationToDetail({
            payload: {
                status: 'INFO',
                message: `Request for LLM analysis for segment ID ${segmentId}...`,
                identifier: `SegmentID:${segmentId}`
            }
        });

        fetch(`/api/articles/analyzed-segments/${segmentId}/run-llm-analysis/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': getCSRFToken(), 'Content-Type': 'application/json' },
        })
        .then(response => response.json().then(data => ({ok: response.ok, status_code: response.status, data})))
        .then(({ok, status_code, data}) => {
            if (ok) { // 202 Accepted
                addNotificationToDetail({
                    payload: {
                        status: 'SUCCESS',
                        message: data.message || `LLM analysis task for segment ID ${segmentId} has been queued.`,
                        identifier: `SegmentID:${segmentId}`
                    }
                });
                // Текст кнопки обновится через WebSocket или можно здесь поменять на "В обработке"
                this.textContent = 'LLM in progress...';
            } else {
                addNotificationToDetail({
                    payload: {
                        status: 'FAILURE',
                        message: `Error starting LLM analysis (${status_code}): ${data.error || JSON.stringify(data)}`,
                        identifier: `SegmentID:${segmentId}`
                    }
                });
                this.disabled = false;
                this.textContent = 'Analyze with LLM';
            }
        })
        .catch(error => {
            console.error('Error running LLM analysis for segment:', error);
            addNotificationToDetail({
                payload: {
                    status: 'FAILURE',
                    message: `Network error: ${error.message}`,
                    identifier: `SegmentID:${segmentId}`
                }
            });
            this.disabled = false;
            this.textContent = 'Analyze with LLM';
        });
    });
});


function openAddReferenceModal() {
    if(addReferenceForm) addReferenceForm.reset(); // Очищаем форму
    if(addReferenceModal) addReferenceModal.style.display = 'flex';
}


function closeAddReferenceModal() {
    if(addReferenceModal) addReferenceModal.style.display = 'none';
}


if (addReferenceForm) {
    addReferenceForm.addEventListener('submit', function(event) {
        event.preventDefault();
        const articleId = "{{ article.pk }}";
        const formData = new FormData(this);

        const manualData = {
            title: formData.get('title'),
            year: formData.get('year')
        };

        const payload = {
            source_article: articleId, // ID текущей (целевой) статьи
            target_article_doi: formData.get('target_article_doi').trim() || null,
            raw_reference_text: formData.get('raw_reference_text').trim(),
            manual_data_json: manualData,
        };

        const saveButton = this.querySelector('button[type="submit"]');
        saveButton.disabled = true;
        saveButton.textContent = 'Saving...';

        fetch(`/api/articles/referencelinks/`, { // POST на эндпоинт списка для создания
            method: 'POST',
            headers: { 'X-CSRFToken': getCSRFToken(), 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(response => response.json().then(data => ({ok: response.ok, status_code: response.status, data})))
        .then(({ok, status_code, data}) => {
            if (ok && status_code === 201) { // 201 Created
                addNotificationToDetail({
                    payload: {
                        status: 'SUCCESS',
                        message: `New reference added successfully (ID: ${data.id}).`
                    }
                });
                closeAddReferenceModal();
                window.location.reload(); // Перезагружаем страницу, чтобы увидеть новую ссылку в списке
            } else {
                let errorMessage = `Error adding reference (${status_code}): `;
                if (data) { for (const field in data) { errorMessage += `${field}: ${Array.isArray(data[field]) ? data[field].join(', ') : data[field]} `; } }
                else { errorMessage += "Unknown server error." }
                addNotificationToDetail({
                    payload: {
                        status: 'FAILURE',
                        message: errorMessage
                    }
                });
            }
        })
        .catch(error => {
            console.error('Error adding new reference:', error);
            addNotificationToDetail({
                payload: {
                    status: 'FAILURE',
                    message: `Network error: ${error.message}`
                }
            });
        })
        .finally(() => {
            if(saveButton) {
                saveButton.disabled = false;
                saveButton.textContent = 'Save new reference';
            }
        });
    });
}


function deleteReference(referenceLinkId, buttonElement) {
    if (!referenceLinkId) return;

    if (!confirm("Are you sure you want to remove this reference? This action is irreversible.")) {
        return;
    }

    buttonElement.disabled = true;
    buttonElement.textContent = 'Deleting...';

    const apiUrl = `/api/articles/referencelinks/${referenceLinkId}/`;

    fetch(apiUrl, {
        method: 'DELETE',
        headers: {
            'X-CSRFToken': getCSRFToken(),
        },
    })
    .then(response => {
        if (response.status === 204) { // 204 No Content - успешное удаление
            return { ok: true, data: { message: "Reference successfully removed." } };
        }
        // Если есть тело ответа с ошибкой
        return response.json().then(data => ({ ok: false, status_code: response.status, data }));
    })
    .then(({ ok, status_code, data }) => {
        if (ok) {
            addNotificationToDetail({
                payload: {
                    status: 'SUCCESS',
                    message: data.message
                }
            });

            // Динамически удаляем HTML элемент ссылки со страницы
            const liElementToRemove = buttonElement.closest('li'); // Находим родительский <li>
            if (liElementToRemove) {
                liElementToRemove.remove();
            }
            // Перезагрузка - более простой вариант, если возникают сложности с динамическим обновлением
            // window.location.reload();
        } else {
            addNotificationToDetail({
                payload: {
                    status: 'FAILURE',
                    message: `Error deleting (${status_code}): ${data.detail || JSON.stringify(data)}`
                }
            });
            buttonElement.disabled = false;
            buttonElement.textContent = 'Delete';
        }
    })
    .catch(error => {
        console.error('Error while deleting link:', error);
        addNotificationToDetail({
            payload: {
                status: 'FAILURE',
                message: `Сетевая ошибка: ${error.message}`
            }
        });
        buttonElement.disabled = false;
        buttonElement.textContent = 'Delete';
    });
}


// Закрытие модального окна при клике вне его (опционально)
window.onclick = function(event) {
    if (event.target == editModal) {
        closeEditModal();
    }
}

// закрытие модального окна при клике вне его
window.addEventListener('click', function(event) {
    if (addReferenceModal && event.target == addReferenceModal) {
        closeAddReferenceModal();
    }

    // Закрытие модального окна создания сегмента при клике вне его
    if (segmentCreationModal && event.target == segmentCreationModal) {
        closeSegmentCreationModal();
    }

    if (addSectionModal && event.target == addSectionModal) {
        closeAddSectionModal();
    }
});

</script>

{% endblock %}